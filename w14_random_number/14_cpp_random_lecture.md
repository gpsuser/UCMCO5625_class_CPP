# Pseudorandom Number Generation in C++

## Learning Outcomes

By the end of this lecture, you should be able to:

* Understand the difference between true random and pseudorandom numbers
* Explain how pseudorandom number generators (PRNGs) work and why they are useful
* Identify the limitations and problems with the traditional `rand()` function
* Use the modern C++ `<random>` library to generate pseudorandom numbers
* Select appropriate PRNG algorithms for different use cases
* Properly seed random number generators using various methods
* Apply different probability distributions to generated random numbers
* Implement custom distributions for specific applications

## Table of Contents

1. [Introduction to Random Numbers in Computing](#1-introduction-to-random-numbers-in-computing)
2. [Understanding Pseudorandom Number Generators](#2-understanding-pseudorandom-number-generators)
3. [The Traditional rand() Function](#3-the-traditional-rand-function)
4. [Linear Congruential Generators](#4-linear-congruential-generators)
5. [Problems with rand()](#5-problems-with-rand)
6. [The Modern C++ random Library](#6-the-modern-c-random-library)
7. [PRNG Algorithms](#7-prng-algorithms)
8. [Seeding Random Number Generators](#8-seeding-random-number-generators)
9. [Working with Distributions](#9-working-with-distributions)
10. [Custom Distributions](#10-custom-distributions)
11. [Resources](#11-resources)

---

## 1. Introduction to Random Numbers in Computing

Random numbers play a crucial role in many computing applications, from simulations and games to cryptography and scientific computing. However, generating truly random numbers on a deterministic computer is fundamentally challenging.

### Initial Experiment

Let's start with a simple experiment to observe an interesting property of random number generation in C++:

```cpp
#include <iostream>

int main()
{
    for(int i = 0; i < 20; i++)
    {
        std::cout << rand() << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**Sample Output (First Run):**
```
41 18467 6334 26500 19169 15724 11478 29358 26962 24464 5705 28145 23281 16827 9961 491 2995 11942 4827 5436
```

**Sample Output (Second Run):**
```
41 18467 6334 26500 19169 15724 11478 29358 26962 24464 5705 28145 23281 16827 9961 491 2995 11942 4827 5436
```

Notice anything unusual? The sequences are identical! This demonstrates a fundamental characteristic of computer-generated random numbers.

---

## 2. Understanding Pseudorandom Number Generators

### What Makes Numbers "Pseudorandom"?

Most random numbers used in computation are not truly random. Instead, they are **pseudorandom** - they appear random but are actually generated by a deterministic algorithm. Given the same initial value (called a **seed**), a pseudorandom number generator will always produce the same sequence.

### Characteristics of Good PRNGs

A quality pseudorandom number generator should satisfy these idealized criteria:

* **Uniform distribution**: Over time, there should be a roughly equal probability of each value occurring
* **Unpredictability**: It should be difficult to predict which value comes next without knowing the underlying algorithm details
* **Reproducibility**: Given the same seed, the sequence can be exactly reproduced

### Why Pseudorandom is Actually Useful

The deterministic nature of pseudorandom numbers is actually advantageous in many contexts:

* **Debugging**: You can reproduce the exact sequence of "random" events
* **Testing**: Run the same test scenario multiple times
* **Simulation**: Replay simulations with identical random conditions
* **Game development**: Implement features like Freecell's numbered games

```
Conceptual Flow:
    
    Seed Value (X0)
         |
         v
    [PRNG Algorithm] --> X1 (first random number)
         |
         v
    [PRNG Algorithm] --> X2 (second random number)
         |
         v
    [PRNG Algorithm] --> X3 (third random number)
         |
        ...
```

### True Random vs. Pseudorandom

While it is possible to obtain truly random numbers from sources like:
* Hardware random number generators
* Atmospheric noise
* Radioactive decay
* APIs such as random.org

In practice, pseudorandom numbers are sufficient for most applications and much more practical to generate.

---

## 3. The Traditional rand() Function

### Basic Usage

The traditional C/C++ approach to generating random numbers uses the `rand()` function from `<cstdlib>`:

```cpp
#include <iostream>
#include <cstdlib>

int main()
{
    std::cout << "Five random numbers: ";
    for(int i = 0; i < 5; i++)
    {
        std::cout << rand() << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**Sample Output:**
```
Five random numbers: 41 18467 6334 26500 19169
```

### Seeding with srand()

If we want different sequences between program runs, we can seed the generator with the system time:

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

int main()
{
    srand(time(0));  // Seed with current time
    
    std::cout << "Five random numbers: ";
    for(int i = 0; i < 5; i++)
    {
        std::cout << rand() << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**Sample Output (First Run):**
```
Five random numbers: 23847 15234 9823 31245 28392
```

**Sample Output (Second Run):**
```
Five random numbers: 19234 28471 5632 14589 22106
```

Now the sequences differ between runs because the time-based seed changes.

---

## 4. Linear Congruential Generators

### The Algorithm

One of the historically popular methods for PRNG implementation is the **Linear Congruential Feedback Generator (LCFG)**, which operates according to this equation:

```
X(n+1) = (a * X(n) + c) % m
```

Where:
* `X(n)` is the current generated number
* `X(n+1)` is the next number in the sequence
* `a`, `c`, and `m` are carefully chosen constants
* `%` is the modulo operation

```
Visual Representation:

Current State: X(n) = 7
Parameters: a = 5, c = 3, m = 16

Step 1: Multiply     5 * 7 = 35
Step 2: Add          35 + 3 = 38
Step 3: Modulo       38 % 16 = 6

Next State: X(n+1) = 6
```

### Implementation Example

Here's a simple implementation of an LCFG:

```cpp
#include <iostream>

int LCFG(int a, int c, int m, int x)
{
    return (a * x + c) % m;
}

int main()
{
    // Using parameters from numerical recipes
    int a = 1664525;
    int c = 1013904223;
    int m = 2147483648;
    
    int current = 42;  // Seed value
    
    std::cout << "First 10 numbers from LCFG:" << std::endl;
    for(int i = 0; i < 10; i++)
    {
        current = LCFG(a, c, m, current);
        std::cout << current << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**Sample Output:**
```
First 10 numbers from LCFG:
1083877533 644564466 1772712227 423618400 651119777 1458451246 1499027571 1975048256 2099766081 1596832790
```

### Common Parameters

Different systems use different parameters for their LCFGs. The choice of `a`, `c`, and `m` significantly affects the quality of the random sequence. Common parameter sets include those from:

* Numerical Recipes
* POSIX
* Microsoft Visual C++
* GCC

Note that these parameters vary between compilers and operating systems, which creates portability issues.

---

## 5. Problems with rand()

While `rand()` is simple to use, it has several significant limitations that make it unsuitable for many modern applications.

### Major Issues

**1. Lack of Control**
* You cannot choose which algorithm to use
* You cannot select specific parameters
* The implementation is compiler and OS dependent

**2. Non-Reproducibility Across Platforms**
* Different compilers use different algorithms
* Results cannot be reproduced across different systems
* Makes cross-platform testing difficult

**3. Thread Safety**
* `rand()` is not thread-safe
* All threads draw from the same global generator
* Can cause race conditions in multithreaded programs

```
Thread Safety Problem:

Thread 1                Thread 2
   |                       |
   |---> rand() -------|   |
   |                   |   |
   |                   |<------ rand()
   |                   |   |
   |      CONFLICT!    |   |
   |                   |   |
   v                   v   v
 Same global generator state
```

### Poor Seeding Practice

Using `time(0)` to seed the generator has serious flaws:

* Returns time in seconds since January 1st, 1970
* A second is a long time for a computer
* Programs started within the same second produce identical sequences
* This is particularly problematic for:
  - Automated testing
  - Server applications handling multiple requests
  - Parallel computations

```cpp
#include <iostream>
#include <cstdlib>
#include <ctime>

int main()
{
    srand(time(0));
    
    std::cout << "Current seed (time in seconds): " << time(0) << std::endl;
    std::cout << "First random number: " << rand() << std::endl;
    
    // If this program runs twice in the same second,
    // it will produce the same "random" number!
    
    return 0;
}
```

**Sample Output:**
```
Current seed (time in seconds): 1706457600
First random number: 238471
```

---

## 6. The Modern C++ random Library

The `<random>` header introduced in C++11 provides a comprehensive solution to the limitations of `rand()`.

### Key Advantages

**1. Independent Generators**
* Construct separate, independent generators
* No shared global state
* Perfect for multithreaded applications

**2. Algorithm Selection**
* Choose from multiple PRNG algorithms
* Use different algorithms for different purposes
* Control algorithm parameters

**3. Better Seeding Options**
* Specified numeric values (for reproducibility)
* System clock (if necessary)
* Output from another random number generator
* `std::random_device` (system-dependent high-quality randomness)

**4. Distribution Support**
* Built-in support for various distributions
* No manual scaling: `rand() % range_size + lower_limit`
* No manual floating-point conversion
* Uniform, normal, binomial, and many other distributions

### Architecture

The `<random>` library separates concerns into two components:

```
    +-----------------+         +------------------+
    |  Random Number  |         |   Distribution   |
    |    Generator    | ------> |     (Shape)      |
    |   (Algorithm)   |         |                  |
    +-----------------+         +------------------+
           |                            |
           v                            v
    Generates uniform          Transforms to desired
    random bits                probability distribution
```

---

## 7. PRNG Algorithms

### Available Algorithms

The `<random>` library provides several algorithm choices:

**1. Linear Congruential Generator** (`std::minstd_rand`)
* Fast and simple
* Uses the LCFG algorithm discussed earlier
* Adequate for simple applications

**2. Mersenne Twister** (`std::mt19937` and `std::mt19937_64`)
* Widely considered the best general-purpose option
* Excellent statistical properties
* Long period (2^19937 - 1)
* Available in 32-bit and 64-bit versions

**3. Subtract with Carry** (`std::ranlux24` and `std::ranlux48`)
* Very high quality randomness
* Slower than Mersenne Twister
* Useful for demanding applications

### Using Mersenne Twister

The standard 32-bit and 64-bit Mersenne Twister implementations are called `mt19937` and `mt19937_64`:

```cpp
#include <random>
#include <iostream>

int main()
{
    std::mt19937 gen;  // Create a 32-bit Mersenne Twister generator
    
    std::cout << "First 20 numbers from unseeded mt19937:" << std::endl;
    for(int i = 0; i < 20; i++)
    {
        std::cout << gen() << std::endl;
    }
    
    return 0;
}
```

**Sample Output:**
```
First 20 numbers from unseeded mt19937:
3499211612
581869302
3890346734
3586334585
545404204
4161255391
3922919429
949333985
2715962298
1323567403
418932835
2350294565
1196140740
809094426
2348838239
4264392720
4112460519
4152267949
2096253954
3596306145
```

### Comparing Generator Output

Notice that even unseeded, the Mersenne Twister produces different results than `rand()`:

```cpp
#include <random>
#include <iostream>
#include <cstdlib>

int main()
{
    std::cout << "Using rand():" << std::endl;
    for(int i = 0; i < 5; i++)
    {
        std::cout << rand() << " ";
    }
    std::cout << std::endl;
    
    std::cout << "\nUsing mt19937:" << std::endl;
    std::mt19937 gen;
    for(int i = 0; i < 5; i++)
    {
        std::cout << gen() << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**Sample Output:**
```
Using rand():
41 18467 6334 26500 19169

Using mt19937:
3499211612 581869302 3890346734 3586334585 545404204
```

---

## 8. Seeding Random Number Generators

### The Importance of Seeding

Without seeding, generators produce the same sequence every time. This is intentional for reproducibility, but often we want different sequences.

### Using std::random_device

`std::random_device` is a system-implemented random number generator that provides high-quality randomness:

```cpp
#include <random>
#include <iostream>

int main()
{
    std::random_device rd;  // System random number generator
    std::mt19937 gen(rd()); // Seed mt19937 with random_device
    
    std::cout << "First 10 numbers from seeded mt19937:" << std::endl;
    for(int i = 0; i < 10; i++)
    {
        std::cout << gen() << std::endl;
    }
    
    return 0;
}
```

**Sample Output (First Run):**
```
First 10 numbers from seeded mt19937:
2847562938
1847293847
3928475629
1847562938
4738291847
2938475628
1938475629
3847562918
2847563928
1938475638
```

**Sample Output (Second Run):**
```
First 10 numbers from seeded mt19937:
3928475619
2938475628
4738291847
2847562938
1938475629
3847562918
1847293847
2938475638
4738291827
1938475649
```

### How std::random_device Works

The implementation details vary by system:

* **GCC**: Uses a cryptographically secure generator periodically reseeded from hardware entropy sources
* **MSVC**: Uses system cryptographic API
* **Much better than system clock**: Provides high-quality seeds even for processes started simultaneously

```
Entropy Sources for random_device:

Hardware noise
CPU temperature variations  }
Disk timing variations      } --> [random_device] --> High quality seed
Network packet timing       }
Keyboard/mouse timing
```

### Seeding for Reproducibility

Sometimes you want reproducible sequences (e.g., for testing). Use a specific seed value:

```cpp
#include <random>
#include <iostream>

int main()
{
    std::mt19937 gen1(12345);  // Seed with specific value
    std::mt19937 gen2(12345);  // Same seed
    
    std::cout << "Generator 1: " << gen1() << " " << gen1() << " " << gen1() << std::endl;
    std::cout << "Generator 2: " << gen2() << " " << gen2() << " " << gen2() << std::endl;
    std::cout << "Both produce identical sequences!" << std::endl;
    
    return 0;
}
```

**Sample Output:**
```
Generator 1: 3992670690 3823185381 1358822685
Generator 2: 3992670690 3823185381 1358822685
Both produce identical sequences!
```

---

## 9. Working with Distributions

### Uniform Integer Distribution

To generate random integers within a specific range, use `std::uniform_int_distribution`:

```cpp
#include <random>
#include <iostream>

int main()
{
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<int> dist(1, 6);  // Dice roll: 1-6
    
    std::cout << "Rolling a dice 20 times:" << std::endl;
    for(int i = 0; i < 20; i++)
    {
        std::cout << dist(gen) << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**Sample Output:**
```
Rolling a dice 20 times:
4 2 6 1 5 3 6 2 4 1 5 6 3 2 4 6 1 5 3 4
```

### Flexibility of Distributions

A powerful feature is that distributions are separate from generators. You can:

* Use the same distribution with different generators
* Use different distributions with the same generator
* Pass generators to distributions as needed

```cpp
#include <random>
#include <iostream>

int main()
{
    std::random_device rd;
    std::mt19937 gen1(rd());
    std::mt19937 gen2(rd());
    
    std::uniform_int_distribution<int> dist(1, 6);
    
    std::cout << "Using generator 1: " << dist(gen1) << std::endl;
    std::cout << "Using generator 2: " << dist(gen2) << std::endl;
    std::cout << "Back to generator 1: " << dist(gen1) << std::endl;
    
    return 0;
}
```

**Sample Output:**
```
Using generator 1: 4
Using generator 2: 2
Back to generator 1: 6
```

### Uniform Real Distribution

For floating-point numbers, use `std::uniform_real_distribution`:

```cpp
#include <random>
#include <iostream>
#include <iomanip>

int main()
{
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_real_distribution<float> dist(1.0, 6.0);
    
    std::cout << std::fixed << std::setprecision(4);
    std::cout << "20 random floats between 1.0 and 6.0:" << std::endl;
    for(int i = 0; i < 20; i++)
    {
        std::cout << dist(gen) << " ";
        if((i + 1) % 5 == 0) std::cout << std::endl;
    }
    
    return 0;
}
```

**Sample Output:**
```
20 random floats between 1.0 and 6.0:
4.2847 2.9183 5.7294 1.3847 4.8293
3.1847 5.9284 2.4718 4.5837 1.9284
5.2847 3.8294 4.1837 2.7394 5.4827
1.8374 4.9283 3.5827 2.2847 5.8294
```

### Normal (Gaussian) Distribution

Many real-world phenomena follow a normal distribution. For example, human heights:

```cpp
#include <random>
#include <iostream>
#include <iomanip>

int main()
{
    std::random_device rd;
    std::mt19937 gen(rd());
    
    // Heights: mean=172cm, standard deviation=6cm
    std::normal_distribution<double> dist(172.0, 6.0);
    
    std::cout << std::fixed << std::setprecision(2);
    std::cout << "Simulating heights of 20 people:" << std::endl;
    for(int i = 0; i < 20; i++)
    {
        std::cout << dist(gen) << "cm ";
        if((i + 1) % 5 == 0) std::cout << std::endl;
    }
    
    return 0;
}
```

**Sample Output:**
```
Simulating heights of 20 people:
174.23cm 168.91cm 177.58cm 171.34cm 175.82cm
169.47cm 173.65cm 166.28cm 178.19cm 172.84cm
170.56cm 175.93cm 168.72cm 173.18cm 176.41cm
169.85cm 174.67cm 171.29cm 168.53cm 177.04cm
```

```
Normal Distribution Visualization:

           *
         * * *
       * * * * *
     * * * * * * *
   * * * * * * * * *
 * * * * * * * * * * *
-----|---|---|---|-----
   164 168 172 176 180
         Mean=172
```

### Other Available Distributions

The `<random>` library provides many other distributions:

* `std::binomial_distribution` - Binomial distribution
* `std::geometric_distribution` - Geometric distribution
* `std::poisson_distribution` - Poisson distribution
* `std::exponential_distribution` - Exponential distribution
* `std::gamma_distribution` - Gamma distribution
* `std::chi_squared_distribution` - Chi-squared distribution
* And many more...

---

## 10. Custom Distributions

### Discrete Distribution with Custom Probabilities

Sometimes we need to assign specific probabilities to individual outcomes. The `std::discrete_distribution` allows us to specify weights for each possible value:

```cpp
#include <random>
#include <iostream>

int main()
{
    std::random_device rd;
    std::mt19937 gen(rd());
    
    // Weighted dice: positions 0-5 represent outcomes 1-6
    // Index 0 (outcome 1): weight 10
    // Index 1 (outcome 2): weight 10
    // Index 2 (outcome 3): weight 10
    // Index 3 (outcome 4): weight 10
    // Index 4 (outcome 5): weight 10
    // Index 5 (outcome 6): weight 50 (5x more likely!)
    std::discrete_distribution<> dist({10, 10, 10, 10, 10, 50});
    
    std::cout << "Rolling weighted dice 100 times:" << std::endl;
    int counts[6] = {0};
    
    for(int i = 0; i < 100; i++)
    {
        int result = dist(gen);
        counts[result]++;
    }
    
    std::cout << "\nResults:" << std::endl;
    for(int i = 0; i < 6; i++)
    {
        std::cout << "Outcome " << (i + 1) << ": " << counts[i] << " times" << std::endl;
    }
    
    return 0;
}
```

**Sample Output:**
```
Rolling weighted dice 100 times:

Results:
Outcome 1: 8 times
Outcome 2: 11 times
Outcome 3: 9 times
Outcome 4: 12 times
Outcome 5: 10 times
Outcome 6: 50 times
```

### Practical Example: Random Item Selection

A common use case is selecting items from a collection with different probabilities:

```cpp
#include <random>
#include <iostream>
#include <string>
#include <vector>

int main()
{
    std::random_device rd;
    std::mt19937 gen(rd());
    
    // Items to choose from
    std::vector<std::string> items = {"Common", "Uncommon", "Rare", "Epic", "Legendary"};
    
    // Probabilities: Common=50%, Uncommon=30%, Rare=15%, Epic=4%, Legendary=1%
    std::discrete_distribution<> dist({50, 30, 15, 4, 1});
    
    std::cout << "Opening 20 loot boxes:" << std::endl;
    for(int i = 0; i < 20; i++)
    {
        int index = dist(gen);
        std::cout << (i + 1) << ". " << items[index] << std::endl;
    }
    
    return 0;
}
```

**Sample Output:**
```
Opening 20 loot boxes:
1. Common
2. Uncommon
3. Common
4. Common
5. Rare
6. Common
7. Uncommon
8. Common
9. Common
10. Uncommon
11. Common
12. Common
13. Uncommon
14. Common
15. Epic
16. Common
17. Rare
18. Common
19. Common
20. Uncommon
```

### Even/Odd Example

Here's an example where even numbers are twice as likely as odd numbers:

```cpp
#include <random>
#include <iostream>

int main()
{
    std::random_device rd;
    std::mt19937 gen(rd());
    
    // Weights for 0-9: even numbers (0,2,4,6,8) weight=2, odd numbers weight=1
    std::discrete_distribution<> dist({2, 1, 2, 1, 2, 1, 2, 1, 2, 1});
    
    std::cout << "Generating 100 numbers (evens twice as likely):" << std::endl;
    int even_count = 0;
    int odd_count = 0;
    
    for(int i = 0; i < 100; i++)
    {
        int num = dist(gen);
        std::cout << num << " ";
        if(num % 2 == 0) even_count++;
        else odd_count++;
    }
    
    std::cout << "\n\nStatistics:" << std::endl;
    std::cout << "Even numbers: " << even_count << std::endl;
    std::cout << "Odd numbers: " << odd_count << std::endl;
    
    return 0;
}
```

**Sample Output:**
```
Generating 100 numbers (evens twice as likely):
8 4 2 6 1 0 4 8 2 6 7 4 0 2 8 6 4 9 2 0 8 4 6 2 5 0 4 8 6 2 3 4 0 8 2 6 4 1 0 8 2 6 4 7 8 0 2 6 4 9 8 0 4 2 6 3 8 4 0 2 6 5 4 8 0 2 6 1 4 8 2 0 6 7 4 8 2 0 6 3 4 8 2 0 6 9 4 8 2 0 6 5 4 8 2 0 6 1 4 8

Statistics:
Even numbers: 67
Odd numbers: 33
```

---

## 11. Resources

### Official Documentation

* **C++ Reference - random**: https://en.cppreference.com/w/cpp/header/random
  Comprehensive documentation of all classes and functions in the `<random>` library

* **C++ Reference - rand**: https://en.cppreference.com/w/cpp/numeric/random/rand
  Documentation for the traditional `rand()` function

### Background Reading

* **Linear Congruential Generator (Wikipedia)**: https://en.wikipedia.org/wiki/Linear_congruential_generator
  Detailed explanation of LCG algorithms and common parameters

* **Mersenne Twister (Wikipedia)**: https://en.wikipedia.org/wiki/Mersenne_Twister
  In-depth coverage of the Mersenne Twister algorithm

* **Pseudorandom Number Generator (Wikipedia)**: https://en.wikipedia.org/wiki/Pseudorandom_number_generator
  General overview of PRNG concepts and applications

### Online Practice

* **HackerRank - Probability**: https://www.hackerrank.com/domains/mathematics/probability
  Practice problems involving probability and random number generation

* **LeetCode - Random Problems**: https://leetcode.com/tag/random/
  Coding challenges that utilize random number generation

### Books

* "The C++ Standard Library" by Nicolai M. Josuttis
  Chapter on Numerics covers the `<random>` library in detail

* "Numerical Recipes: The Art of Scientific Computing" by Press et al.
  Comprehensive coverage of random number generation algorithms

### Additional Resources

* **Random.org**: https://www.random.org
  Service providing truly random numbers via atmospheric noise

* **PCG Random**: https://www.pcg-random.org
  Information about PCG (Permuted Congruential Generator), a modern alternative to Mersenne Twister

---